/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef chord_TYPES_H
#define chord_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace chorddb { namespace middleware {

enum ErrorCode {
  UNKNOWN = 0
};

extern const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES;

typedef struct _ChordException__isset {
  _ChordException__isset() : errorCode(false), what(false) {}
  bool errorCode;
  bool what;
} _ChordException__isset;

class ChordException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "19B5240589E680301A7E32DF3971EFBE";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

  ChordException() : errorCode((ErrorCode)0), what() {
  }

  virtual ~ChordException() throw() {}

  ErrorCode errorCode;
  std::string what;

  _ChordException__isset __isset;

  void __set_errorCode(const ErrorCode val) {
    errorCode = val;
  }

  void __set_what(const std::string& val) {
    what = val;
  }

  bool operator == (const ChordException & rhs) const
  {
    if (!(errorCode == rhs.errorCode))
      return false;
    if (!(what == rhs.what))
      return false;
    return true;
  }
  bool operator != (const ChordException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChordException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ChordException &a, ChordException &b);

typedef struct _Node__isset {
  _Node__isset() : id(false), port(false), address(false) {}
  bool id;
  bool port;
  bool address;
} _Node__isset;

class Node {
 public:

  static const char* ascii_fingerprint; // = "B60006AAF0CAC4C90B413EB63943B6E9";
  static const uint8_t binary_fingerprint[16]; // = {0xB6,0x00,0x06,0xAA,0xF0,0xCA,0xC4,0xC9,0x0B,0x41,0x3E,0xB6,0x39,0x43,0xB6,0xE9};

  Node() : id(0), port(0), address() {
  }

  virtual ~Node() throw() {}

  int64_t id;
  int32_t port;
  std::string address;

  _Node__isset __isset;

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_port(const int32_t val) {
    port = val;
  }

  void __set_address(const std::string& val) {
    address = val;
  }

  bool operator == (const Node & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(address == rhs.address))
      return false;
    return true;
  }
  bool operator != (const Node &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Node &a, Node &b);

typedef struct _GetSuccessorResponse__isset {
  _GetSuccessorResponse__isset() : nodeIsSuccessor(false), node(false) {}
  bool nodeIsSuccessor;
  bool node;
} _GetSuccessorResponse__isset;

class GetSuccessorResponse {
 public:

  static const char* ascii_fingerprint; // = "0463006BD997D70DE43B24DC39A071CB";
  static const uint8_t binary_fingerprint[16]; // = {0x04,0x63,0x00,0x6B,0xD9,0x97,0xD7,0x0D,0xE4,0x3B,0x24,0xDC,0x39,0xA0,0x71,0xCB};

  GetSuccessorResponse() : nodeIsSuccessor(0) {
  }

  virtual ~GetSuccessorResponse() throw() {}

  bool nodeIsSuccessor;
  Node node;

  _GetSuccessorResponse__isset __isset;

  void __set_nodeIsSuccessor(const bool val) {
    nodeIsSuccessor = val;
  }

  void __set_node(const Node& val) {
    node = val;
  }

  bool operator == (const GetSuccessorResponse & rhs) const
  {
    if (!(nodeIsSuccessor == rhs.nodeIsSuccessor))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const GetSuccessorResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetSuccessorResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GetSuccessorResponse &a, GetSuccessorResponse &b);

typedef struct _GetConfigurationResponse__isset {
  _GetConfigurationResponse__isset() : leveldbSync(false), overlayName(false) {}
  bool leveldbSync;
  bool overlayName;
} _GetConfigurationResponse__isset;

class GetConfigurationResponse {
 public:

  static const char* ascii_fingerprint; // = "1767FFB0CB3D9275BC64B198AB3B8A8B";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x67,0xFF,0xB0,0xCB,0x3D,0x92,0x75,0xBC,0x64,0xB1,0x98,0xAB,0x3B,0x8A,0x8B};

  GetConfigurationResponse() : leveldbSync(0), overlayName() {
  }

  virtual ~GetConfigurationResponse() throw() {}

  bool leveldbSync;
  std::string overlayName;

  _GetConfigurationResponse__isset __isset;

  void __set_leveldbSync(const bool val) {
    leveldbSync = val;
  }

  void __set_overlayName(const std::string& val) {
    overlayName = val;
  }

  bool operator == (const GetConfigurationResponse & rhs) const
  {
    if (!(leveldbSync == rhs.leveldbSync))
      return false;
    if (!(overlayName == rhs.overlayName))
      return false;
    return true;
  }
  bool operator != (const GetConfigurationResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetConfigurationResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GetConfigurationResponse &a, GetConfigurationResponse &b);

typedef struct _Entity__isset {
  _Entity__isset() : id(false), key(false), value(false) {}
  bool id;
  bool key;
  bool value;
} _Entity__isset;

class Entity {
 public:

  static const char* ascii_fingerprint; // = "0C4016F101C6C444DB4E691757431FAD";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0x40,0x16,0xF1,0x01,0xC6,0xC4,0x44,0xDB,0x4E,0x69,0x17,0x57,0x43,0x1F,0xAD};

  Entity() : id(0), key(), value() {
  }

  virtual ~Entity() throw() {}

  int64_t id;
  std::string key;
  std::string value;

  _Entity__isset __isset;

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const Entity & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(key == rhs.key))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Entity &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Entity & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Entity &a, Entity &b);

}} // namespace

#endif
